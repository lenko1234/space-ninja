<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corte Esmeralda - Fixed</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: monospace;
        }

        #score-board {
            position: absolute;
            top: 40px;
            right: 20px;
            color: #50c878;
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(80, 200, 120, 0.8);
            z-index: 10;
        }

        #status {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff6b6b;
            font-size: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        #status.show {
            opacity: 1;
        }

        canvas {
            display: block;
        }

        #trail-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <div id="score-board">0</div>
    <div id="status">Esperando conexión...</div>
    <canvas id="trail-container"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        let scene, camera, renderer;
        let stars = [];
        let targets = [];
        let particles = [];

        // Variable de Score limpia
        let score = 0;
        const scoreElement = document.getElementById('score-board');
        const statusDisplay = document.getElementById('status');

        // Configuración
        const GAME_SPEED = 0.8;
        const STAR_SPAWN_RATE = 2;
        const TARGET_SPAWN_RATE = 60; // Un poco más espaciados para evitar caos
        let frameCount = 0;

        // Variables de interacción
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const trailCanvas = document.getElementById('trail-container');
        const trailCtx = trailCanvas.getContext('2d');
        let trailPoints = [];
        let handActive = false;

        // --- SOCKET.IO ---
        const socket = io();

        socket.on('connect', () => {
            console.log('✅ Conectado');
            showStatus('✅ Sistema Conectado');
        });

        socket.on('disconnect', () => {
            showStatus('❌ Desconectado');
        });

        socket.on('hand-data', (data) => {
            if (data.detected === false) {
                handActive = false;
                return;
            }
            handActive = true;
            updateInput(data.x * window.innerWidth, data.y * window.innerHeight);
        });

        function showStatus(msg) {
            statusDisplay.textContent = msg;
            statusDisplay.classList.add('show');
            setTimeout(() => statusDisplay.classList.remove('show'), 3000);
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505); // Negro muy leve para profundidad
            scene.fog = new THREE.FogExp2(0x000000, 0.04);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x50c878, 0.4);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(0, 10, 10);
            scene.add(dirLight);

            window.addEventListener('resize', onWindowResize);
            // Control SOLO por mano (sin mouse)
            resizeTrailCanvas();
        }

        function spawnStar() {
            const geometry = new THREE.PlaneGeometry(0.15, 0.15);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            const star = new THREE.Mesh(geometry, material);
            const range = 40;
            star.position.set((Math.random() - 0.5) * range, (Math.random() - 0.5) * range, -80);
            stars.push(star);
            scene.add(star);
        }

        function spawnTarget() {
            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const material = new THREE.MeshPhongMaterial({
                color: 0x50c878,
                shininess: 100,
                emissive: 0x004400
            });
            const cube = new THREE.Mesh(geometry, material);

            // Spawn más controlado
            const range = 10;
            cube.position.set((Math.random() - 0.5) * range, (Math.random() - 0.5) * range, -60);

            cube.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);

            // Wireframe
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xafffba }));
            cube.add(line);

            cube.userData = {
                rotSpeed: { x: (Math.random() - 0.5) * 0.05, y: (Math.random() - 0.5) * 0.05 },
                isDead: false // Bandera de vida
            };

            targets.push(cube);
            scene.add(cube);
        }

        function createExplosion(pos) {
            for (let i = 0; i < 15; i++) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: 0xafffba });
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos);
                p.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)
                ).multiplyScalar(0.5);
                p.userData.life = 1.0;
                particles.push(p);
                scene.add(p);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            frameCount++;

            // Spawns
            if (frameCount % STAR_SPAWN_RATE === 0) spawnStar();
            if (frameCount % TARGET_SPAWN_RATE === 0) spawnTarget();

            // Mover Estrellas
            for (let i = stars.length - 1; i >= 0; i--) {
                stars[i].position.z += GAME_SPEED * 0.5;
                if (stars[i].position.z > 10) {
                    scene.remove(stars[i]);
                    stars.splice(i, 1);
                }
            }

            // Mover Targets
            for (let i = targets.length - 1; i >= 0; i--) {
                const cube = targets[i];
                cube.position.z += GAME_SPEED;
                cube.rotation.x += cube.userData.rotSpeed.x;
                cube.rotation.y += cube.userData.rotSpeed.y;

                // Limpieza si pasa la cámara
                if (cube.position.z > 8) {
                    scene.remove(cube);
                    targets.splice(i, 1);
                }
            }

            // Partículas
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.userData.life -= 0.05;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            checkIntersections();
            drawTrail();
            renderer.render(scene, camera);
        }

        function checkIntersections() {
            // CRÍTICO: Si no hay mano detectada, NO hacer nada
            if (!handActive) return;

            raycaster.setFromCamera(mouse, camera);

            // Buscamos intersecciones SOLO en los cubos padre (NO recursive)
            const intersects = raycaster.intersectObjects(targets, false);

            if (intersects.length > 0) {
                let hitObject = intersects[0].object;

                // --- VALIDACIONES DE SEGURIDAD ---

                // 1. Verificar que el objeto tiene userData (seguridad)
                if (!hitObject.userData) return;

                // 2. Si ya está muerto, ignorar INMEDIATAMENTE
                if (hitObject.userData.isDead === true) return;

                // 3. Distancia de seguridad
                if (intersects[0].distance > 12) return;

                // 4. Verificar que está en la lista de targets
                const index = targets.indexOf(hitObject);
                if (index === -1) return;

                // --- AQUÍ PROCESAMOS EL CORTE ---

                // CRÍTICO: Marcar como muerto y eliminar de targets PRIMERO
                hitObject.userData.isDead = true;
                targets.splice(index, 1);

                // Ahora sí, efectos visuales y puntos
                hitObject.visible = false;
                createExplosion(hitObject.position);
                score += 100;
                scoreElement.textContent = score;

                console.log("⚔️ CORTE! Puntos:", score);

                // Eliminar de la escena
                scene.remove(hitObject);
            }
        }

        // --- INPUT & TRAIL ---
        function updateInput(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            trailPoints.push({ x: x, y: y, age: 1.0 });
        }

        function drawTrail() {
            trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
            trailCtx.lineCap = 'round'; trailCtx.lineJoin = 'round';

            if (trailPoints.length < 2) return;

            trailCtx.beginPath();
            trailCtx.moveTo(trailPoints[0].x, trailPoints[0].y);

            for (let i = 1; i < trailPoints.length; i++) {
                trailCtx.lineTo(trailPoints[i].x, trailPoints[i].y);
            }

            trailCtx.strokeStyle = 'rgba(80, 200, 120, 0.8)';
            trailCtx.lineWidth = 8;
            trailCtx.shadowBlur = 15;
            trailCtx.shadowColor = '#50c878';
            trailCtx.stroke();

            // Envejecer rastro
            for (let i = trailPoints.length - 1; i >= 0; i--) {
                trailPoints[i].age -= 0.15;
                if (trailPoints[i].age <= 0) trailPoints.splice(i, 1);
            }
        }

        function resizeTrailCanvas() {
            trailCanvas.width = window.innerWidth;
            trailCanvas.height = window.innerHeight;
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            resizeTrailCanvas();
        }
    </script>
</body>

</html>