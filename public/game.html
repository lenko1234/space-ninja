<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corte Esmeralda - Fixed</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: monospace;
        }

        #score-board {
            position: absolute;
            top: 40px;
            right: 20px;
            color: #50c878;
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(80, 200, 120, 0.8);
            z-index: 10;
        }

        #status {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff6b6b;
            font-size: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        #status.show {
            opacity: 1;
        }

        canvas {
            display: block;
        }

        #trail-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <div id="score-board">0</div>
    <div id="status">Esperando conexión...</div>
    <canvas id="trail-container"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        let scene, camera, renderer;
        let stars = [];
        let targets = [];
        let particles = [];

        // Variable de Score limpia
        let score = 0;
        const scoreElement = document.getElementById('score-board');
        const statusDisplay = document.getElementById('status');

        // Configuración
        const GAME_SPEED = 0.8;
        const STAR_SPAWN_RATE = 2;
        const TARGET_SPAWN_RATE = 60; // Un poco más espaciados para evitar caos
        let frameCount = 0;

        // Variables de interacción
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const trailCanvas = document.getElementById('trail-container');
        const trailCtx = trailCanvas.getContext('2d');
        let trailPoints = [];
        let handActive = false;

        // --- SOCKET.IO ---
        const socket = io();

        socket.on('connect', () => {
            console.log('✅ Conectado');
            showStatus('✅ Sistema Conectado');
        });

        socket.on('disconnect', () => {
            showStatus('❌ Desconectado');
        });

        socket.on('hand-data', (data) => {
            if (data.detected === false) {
                handActive = false;
                return;
            }
            handActive = true;
            updateInput(data.x * window.innerWidth, data.y * window.innerHeight);
        });

        function showStatus(msg) {
            statusDisplay.textContent = msg;
            statusDisplay.classList.add('show');
            setTimeout(() => statusDisplay.classList.remove('show'), 3000);
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505); // Negro muy leve para profundidad
            scene.fog = new THREE.FogExp2(0x000000, 0.04);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x50c878, 0.4);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(0, 10, 10);
            scene.add(dirLight);

            window.addEventListener('resize', onWindowResize);
            // Control SOLO por mano (sin mouse)
            resizeTrailCanvas();
        }

        function spawnStar() {
            const geometry = new THREE.PlaneGeometry(0.15, 0.15);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            const star = new THREE.Mesh(geometry, material);
            const range = 40;
            star.position.set((Math.random() - 0.5) * range, (Math.random() - 0.5) * range, -80);
            stars.push(star);
            scene.add(star);
        }

        function spawnTarget() {
            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const material = new THREE.MeshPhongMaterial({
                color: 0x50c878,
                shininess: 100,
                emissive: 0x004400
            });
            const cube = new THREE.Mesh(geometry, material);

            // Spawn más controlado
            const range = 10;
            cube.position.set((Math.random() - 0.5) * range, (Math.random() - 0.5) * range, -60);

            cube.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);

            // Wireframe
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xafffba }));
            cube.add(line);

            cube.userData = {
                bornAt: Date.now(), // Timestamp de nacimiento para escudo
                rotSpeed: { x: (Math.random() - 0.5) * 0.05, y: (Math.random() - 0.5) * 0.05 }
            };

            targets.push(cube);
            scene.add(cube);
        }

        function createExplosion(pos) {
            for (let i = 0; i < 15; i++) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: 0xafffba });
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos);
                p.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)
                ).multiplyScalar(0.5);
                p.userData.life = 1.0;
                particles.push(p);
                scene.add(p);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            frameCount++;

            // Spawns
            if (frameCount % STAR_SPAWN_RATE === 0) spawnStar();
            if (frameCount % TARGET_SPAWN_RATE === 0) spawnTarget();

            // Mover Estrellas
            for (let i = stars.length - 1; i >= 0; i--) {
                stars[i].position.z += GAME_SPEED * 0.5;
                if (stars[i].position.z > 10) {
                    scene.remove(stars[i]);
                    stars.splice(i, 1);
                }
            }

            // Mover Targets
            for (let i = targets.length - 1; i >= 0; i--) {
                const cube = targets[i];
                cube.position.z += GAME_SPEED;
                cube.rotation.x += cube.userData.rotSpeed.x;
                cube.rotation.y += cube.userData.rotSpeed.y;

                // Limpieza si pasa la cámara
                if (cube.position.z > 8) {
                    scene.remove(cube);
                    targets.splice(i, 1);
                }
            }

            // Partículas
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.userData.life -= 0.05;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            checkIntersections();
            drawTrail();
            renderer.render(scene, camera);
        }

        function checkIntersections() {
            // Si no hay mano detectada, no hacer nada
            if (!handActive) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(targets, false);

            if (intersects.length > 0) {
                let hitObject = intersects[0].object;

                // ESCUDO DE NACIMIENTO: Protección de 0.5 segundos
                const age = Date.now() - hitObject.userData.bornAt;
                if (age < 500) return;

                // Eliminar de la lista de targets PRIMERO
                const index = targets.indexOf(hitObject);
                if (index > -1) {
                    targets.splice(index, 1);
                }

                // Efectos y puntos
                createExplosion(hitObject.position);
                score += 100;
                scoreElement.textContent = score;
                console.log("⚔️ CORTE! Puntos:", score);

                // Eliminar de la escena
                scene.remove(hitObject);
            }
        }

        // --- INPUT & TRAIL ---
        function updateInput(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            trailPoints.push({ x: x, y: y, age: 1.0 });
        }

        function drawTrail() {
            trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);

            // Si hay muy pocos puntos, no dibujamos para evitar errores
            if (trailPoints.length < 3) {
                actualizarEdadPuntos();
                return;
            }

            // --- CONFIGURACIÓN ESTÉTICA ---
            // Color base esmeralda
            trailCtx.fillStyle = 'rgba(80, 200, 120, 0.85)';
            trailCtx.shadowBlur = 25;
            trailCtx.shadowColor = '#50c878';

            trailCtx.beginPath();

            // --- ALGORITMO DE CINTA (RIBBON) ---
            // En lugar de una línea, vamos a dibujar un polígono que rodea los puntos.
            // Calcularemos el "lado izquierdo" y el "lado derecho" del corte.

            // 1. DIBUJAR EL LADO IZQUIERDO (Ida)
            for (let i = 0; i < trailPoints.length; i++) {
                const point = trailPoints[i];

                // Calculamos el grosor: El inicio (i=0) es la cola (fino), el final es la cabeza (grueso)
                // Invertimos lógica: los puntos viejos (i=0) son la cola.
                // Cuanto más alto el índice i, más nuevo es el punto.

                // Grosor dinámico: de 2px (cola) a 15px (cabeza)
                const progress = i / (trailPoints.length - 1);
                const width = 2 + (15 * Math.pow(progress, 2));

                // Calcular ángulo hacia el siguiente punto para saber la perpendicular
                let dx = 0, dy = 0;
                if (i < trailPoints.length - 1) {
                    dx = trailPoints[i + 1].x - point.x;
                    dy = trailPoints[i + 1].y - point.y;
                } else if (i > 0) {
                    // Para el último punto, usamos el ángulo del anterior
                    dx = point.x - trailPoints[i - 1].x;
                    dy = point.y - trailPoints[i - 1].y;
                }

                // Matemáticas de vectores para obtener la perpendicular
                const angle = Math.atan2(dy, dx);
                const sin = Math.sin(angle);
                const cos = Math.cos(angle);

                // Offset perpendicular (Lado Izquierdo)
                // -sin y +cos nos da la rotación de 90 grados
                const px = point.x - sin * (width / 2);
                const py = point.y + cos * (width / 2);

                if (i === 0) {
                    trailCtx.moveTo(px, py);
                } else {
                    trailCtx.lineTo(px, py);
                }
            }

            // 2. PUNTA REDONDEADA (Curva en la cabeza del corte)
            const last = trailPoints[trailPoints.length - 1];
            // Hacemos un pequeño arco en la punta para que no quede cuadrada
            trailCtx.arc(last.x, last.y, 8, 0, Math.PI * 2);

            // 3. DIBUJAR EL LADO DERECHO (Vuelta)
            // Recorremos los puntos hacia atrás para cerrar la forma
            for (let i = trailPoints.length - 1; i >= 0; i--) {
                const point = trailPoints[i];

                // Mismo cálculo de grosor
                const progress = i / (trailPoints.length - 1);
                const width = 2 + (15 * Math.pow(progress, 2));

                // Mismo cálculo de ángulo
                let dx = 0, dy = 0;
                if (i < trailPoints.length - 1) {
                    dx = trailPoints[i + 1].x - point.x;
                    dy = trailPoints[i + 1].y - point.y;
                } else if (i > 0) {
                    dx = point.x - trailPoints[i - 1].x;
                    dy = point.y - trailPoints[i - 1].y;
                }

                const angle = Math.atan2(dy, dx);
                const sin = Math.sin(angle);
                const cos = Math.cos(angle);

                // Offset perpendicular INVERSO (Lado Derecho)
                const px = point.x + sin * (width / 2);
                const py = point.y - cos * (width / 2);

                trailCtx.lineTo(px, py);
            }

            trailCtx.closePath();

            // Relleno verde esmeralda
            trailCtx.fill();

            actualizarEdadPuntos();
        }

        // Función de limpieza (sin cambios, solo para asegurar que la tengas)
        function actualizarEdadPuntos() {
            for (let i = trailPoints.length - 1; i >= 0; i--) {
                trailPoints[i].age -= 0.12;
                if (trailPoints[i].age <= 0) trailPoints.splice(i, 1);
            }
            if (trailPoints.length > 25) trailPoints.shift();
        }

        function resizeTrailCanvas() {
            trailCanvas.width = window.innerWidth;
            trailCanvas.height = window.innerHeight;
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            resizeTrailCanvas();
        }
    </script>
</body>

</html>